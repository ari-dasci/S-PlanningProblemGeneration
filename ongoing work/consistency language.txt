>>> Create a language for expressing consistency rules


------- Data structures

>> Consistency checking methods

	> check_continuous_consistency_state_and_action(cls, curr_state, action, obj_types)
	  curr_state: RelationalState (objects and atoms)
	  action: atom to add (['on', [1,0]])
	  obj_types: type of each object in the atom @action (e.g., ['block', 'block'])

	> check_eventual_consistency_state(cls, curr_state):
	  curr_state: RelationalState (objects and atoms)

>> Data structures

	> RelationalState: class storing a PDDL state
		> Domain information (lifted)
			- types: existing object types, stored as a tuple
				Example: ('airplane', 'airport')

			- type_hierarchy: which type inherits from which
				Dictionary where keys are types and values are sets of the children types
				Example: {'vehicle':{'truck', 'airplane'}, 'truck':{'truck'}}

			- predicates: predicate names and what object types they are instantiated on
			    Stored as a tuple of tuples of tuples
				Example: ( ('on', ('block','block')), ('handempty', ()) )

		> Problem information (ground)
			- objects: objects in the state
			    Stored as a <<list>> of their types
			    Example: ['airplane', 'airport', 'city', 'city']

			- atoms: atoms in the state
				Stored as a set of tuples, where each tuple contains an atom,
				as the name of the predicate and the obj indexes it is instantiated on
				Example: { ('in-city', (1,0)), ('at', (2,1)) }

------- Requirements

> Base checks (done everytime, for every domain)
  Note: this should be efficient to do

	- sanity checks curr_state
		- It is instanceof RelationalState

		> In check_eventual_consistency_state
			- The state contains at least one atom of each required predicate type

	- sanity checks action
		- it is a tuple
		- action[0] is a string and the name is in available_predicates
		- action[1] is a tuple of integers
		- action[1] contains no repeated objects (integers) 

	- sanity checks obj_types
		- it is a tuple of strings
		- each type in obj_types is a child type of the corresponding type in the predicate
		  associated with the atom to add (@action) -> very expensive to check


> Declarative (FOL) functionality -> we need to parse the RelationalState, action and obj_types and obtain the corresponding knowledge base

	- FOL formulas where constants are objects and with the state atoms
	- pred_type(atom, pred) -> true if atom is of predicate type "pred"
	- arity(atom, ar) -> true if the arity of the atom is "ar"
	- type(obj, t) -> true if the object is of type "t"
	- child_type(obj, t) -> true if the object is of type "t" OR
	  its type inherits from t
	- new(obj) -> true if the object is not in the state (it is virtual)

	> count(expr) -> return number of var substitutions that make
	  true the expression
	  Example: "how many locations does a city "city" have?" ->
	           count( in-city(X, city) AND type(X, location) )


> Imperative functionality:
	- Creo que pasando como parámetro relational state es suficiente, aunque quizás puedo crear "shortcut methods"
	  como is_new(obj)

	- is_new(obj) -> true if obj is not in the state (it is a virtual object)
	--- Más


--------------- NUEVO

>>> Estructura de clases

	> ConsistencyValidator (creado por mí, abstract class) -> Se llama desde NeSIG
		- kb (knowledge base, como class attribute)

		- evaluate(cls, Formula o Count)
		- _preprocess_and_check_continuous_consistency_state_and_action(cls, rel_state, pred_name, atom_obj_inds, atom_obj_types)
		- _preprocess_and_check_eventual_consistency_state(cls, rel_state)

			Estos dos métodos (abstractos) anteriores se encargan de crear la knowledge base (ver si creo un context manager) y hacer las comprobaciones estándar
			(objs del tipo correcto, sin objetos repetidos, el átomo no está ya en el estado, etc.)
			Tras esto, llaman a check_continuous_consistency_state_and_action y check_eventual_consistency_state (métodos proporcionados por el usuario)

	> ConsistencyValidator<Dominio> (creado por el usuario, hereda de ConsistencyValidator)
		- check_continuous_consistency_state_and_action(cls, rel_state, pred_name, atom_obj_inds, atom_obj_types)
		- check_eventual_consistency_state(cls, rel_state)




> Método check_consistency_state_and_action del usuario
  Params: (rel_state, pred_name, atom_obj_inds (una tupla de ints), atom_obj_types (una tupla de strings))

  >> Parámetros atom_obj_inds (ints) y atom_obj_types (strs) pueden usarse con RelationalState pero no con FOL! (FOL necesita variables y constantes)

  	> Si quiere usar evaluate, el usuario debe crear variables y constantes de manera "manual" (Ej.: o1 = Constant(atom_obj_inds[0]))

  Programación funcional -> usar métodos y propiedades de RelationalState
  	- Nota: >> los objetos virtuales NO están en el rel_state <<
  	        Debería añadir un método is_virtual(obj)

  	- Añadir propiedades obj_types y obj_inds

  Programación declarativa -> usar clases FOL
  	- Nota: >> los objetos virtual SÍ están en la knowledge base
  		- Cada objeto virtual tiene un átomo virtual(obj)

  	- Se crea un método evaluate() al que se le pasa una expresión FOL
  	  y llama sobre esta expresión a evaluate con el knowledge base


> Método check_eventual_consistency_state del usuario
	Params: (rel_state)


