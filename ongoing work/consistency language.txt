>>> Create a language for expressing consistency rules


------- Data structures

>> Consistency checking methods

	> check_continuous_consistency_state_and_action(cls, curr_state, action, obj_types)
	  curr_state: RelationalState (objects and atoms)
	  action: atom to add (['on', [1,0]])
	  obj_types: type of each object in the atom @action (e.g., ['block', 'block'])

	> check_eventual_consistency_state(cls, curr_state):
	  curr_state: RelationalState (objects and atoms)

>> Data structures

	> RelationalState: class storing a PDDL state
		> Domain information (lifted)
			- types: existing object types, stored as a tuple
				Example: ('airplane', 'airport')

			- type_hierarchy: which type inherits from which
				Dictionary where keys are types and values are sets of the children types
				Example: {'vehicle':{'truck', 'airplane'}, 'truck':{'truck'}}

			- predicates: predicate names and what object types they are instantiated on
			    Stored as a tuple of tuples of tuples
				Example: ( ('on', ('block','block')), ('handempty', ()) )

		> Problem information (ground)
			- objects: objects in the state
			    Stored as a <<list>> of their types
			    Example: ['airplane', 'airport', 'city', 'city']

			- atoms: atoms in the state
				Stored as a set of tuples, where each tuple contains an atom,
				as the name of the predicate and the obj indexes it is instantiated on
				Example: { ('in-city', (1,0)), ('at', (2,1)) }

------- Requirements

> Base checks (done everytime, for every domain)
  Note: this should be efficient to do

	- sanity checks curr_state
		- It is instanceof RelationalState

		> In check_eventual_consistency_state
			- The state contains at least one atom of each required predicate type

	- sanity checks action
		- it is a tuple
		- action[0] is a string and the name is in available_predicates
		- action[1] is a tuple of integers
		- action[1] contains no repeated objects (integers) 

	- sanity checks obj_types
		- it is a tuple of strings
		- each type in obj_types is a child type of the corresponding type in the predicate
		  associated with the atom to add (@action) -> very expensive to check


> Declarative (FOL) functionality -> we need to parse the RelationalState, action and obj_types and obtain the corresponding knowledge base

	- FOL formulas where constants are objects and with the state atoms
	- pred_type(atom, pred) -> true if atom is of predicate type "pred"
	- arity(atom, ar) -> true if the arity of the atom is "ar"
	- type(obj, t) -> true if the object is of type "t"
	- child_type(obj, t) -> true if the object is of type "t" OR
	  its type inherits from t
	- new(obj) -> true if the object is not in the state (it is virtual)

	> count(expr) -> return number of var substitutions that make
	  true the expression
	  Example: "how many locations does a city "city" have?" ->
	           count( in-city(X, city) AND type(X, location) )


> Imperative functionality:

	- get_type(obj) -> return type of obj
	- is_new(obj) -> true if obj is not in the state (it is a virtual object)
	--- Más


----------- Estructura del código

> Clases para implementar FOL
	- Hacer que los objetos puedan ser índices!!!

	- FOL formulas con quantifiers, and, or, not, etc.
	- También con equality y inequality
	- También con counting quantifiers
	- Un método "proves" para ver si dado una FOL formula (correspondiente al PDDL state),
	  se puede demostrar que otra fórmula (la consistency rule) es true o no


> Métodos para imperative functionality (clase padre consistency_validator)
 	- Cuando se llama al método de consistency_check dado por el usuario, se crea un 
	  ContextManager que hace que el RelState pasado como parámetro esté disponible
	  (y que métodos como get_type(obj) se puedan llamar sin pasar el RelState como argumento)

> Métodos llamados desde el código interno de NeSIG (mismos parámetros que los métodos
  que usa el consistency validator actual) (clase padre consistency_validator)
	- A partir de los argumentos, se crea un knowledge base en FOL y también se almacena
	  en el context_manager

	- Se llama al método de consistency_check proporcionado por el usuario


> Métodos proporcionados por el usuario (clase hija consistency_validator), que únicamente reciben como 
  parámetros:
	- El nombre del átomo a añadir y una lista de los objetos en los que está instanciado
	  (para comprobar la continuous consistency)
	- Sin parámetros (para la eventual consistency)

	Estos dos métodos devuelven true o false, según si se cumplen las consistency rules


>>> Clases
	- Consistency validator (padre)
	- Consistency validator (hijo, hereda)
	- Clases para FOL formulas